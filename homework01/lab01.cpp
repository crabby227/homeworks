#include  <iostream>    
using namespace std;

int main()
{

 //**********************************************************
  //Задание 1. Работа с отладчиком. Базовые типы данных. Выполняя программу по шагам, 
  //следите за значениями переменных и интерпретируйте результат (помните, что 
  //количество байт, отводимых под int, системо-зависимо).
  //Обратите внимание на разную интерпретацию отладчиком signed и unsigned целых типов 
  //данных, а также на внутреннее представление отрицательных целых чисел.

  
  char cByte = 'A'; // Значение 'A' - код ASCII 65
  cByte    = 0x42; // Значение - шестнадцатеричное число, код ASCII 66 
  cByte    = 66; // код ASCII
  cByte    = -1; // Нет символа на данное значение  

  unsigned char ucByte = 0x41; // Шестнадцатеричное число, код ASCII 65
  ucByte   = 'B'; // Значение 'B' - код ASCII 66
  ucByte   =  -1; // Нельзя присвоить отрицательное значение, так как unsigned -1 становится 255 (предел) и ему присваевается значение ASCII

  int iInt =  0xffffffff; // Выше предела доступных чисел, задается -1

  unsigned int uiInt = 0xffffffff; // предел 4294967295

  float fFloat = 1.f;  // 1 типа float
  double dDouble = 1.; // 1 типа double

  // Выполните фрагмент, приведенный далее. В комментариях отразите,
  // что реально заносится в переменную. Объясните разницу между этим 
  // значением и инициализатором.

  double d = 0.1234567890123456789123456789; // 0.12345678901234568, предел цифр после запятой - 15-17, значение округлиляется
  float  f = 0.1234567890123456789123456789; // 0.123456791, предел цифр после запятой - 6-9, значение тоже округлено

  d  =  1.; // Заносится 1, так как после запятой ничего нет
  d  =  0.999999999999999999999999999999999; // Значение 1, потому что превышен предел цифр после запятой + округлено

  
  // В комментариях напишите результат, возвращаемый оператором sizeof для
  // переменной типа wchar_t (ее размер)
  wchar_t cw = L'\u0424'; // Ф
  size_t n = sizeof(cw); // 2 байта


// **************************************************************
  //Задание 2a. Неявное приведение типов данных.
  //Объясните разницу результата при выполнении (1) и (2):
  //Покажите явно (напишите в коде) преобразования, которые неявно выполняет компилятор

  iInt=1;
  double dDouble1=iInt/3;    // (1) Получаем 0
  // double dDouble2 = static_cast<double>(iInt / 3.);
  // Int - целое число, поэтому при его делении на такое же целое получается число с типом Int, округление
  double dDouble2=iInt/3.;  // (2) Получаем 0.33333333333333331
  // double dDouble2 = static_cast<double>(iInt) / 3.;
  // Делим double на тип double, поэтому получаем double.

  // Ассоциативность операторов.
  // Синтаксис языка C допускает "цепочечное" присваивание
  // (как в строках (1) и (2)). Посмотрев результаты выполнения строк (1) и (2)
  // (значения переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок 
  // выполения присваиваний при цепочечной записи и объясните результат.
  // Расставте скобки, явно определяющие порядок выполнения, как это сделал бы компилятор.
  // Объясните (в комментариях) предупреждения (warnings) компилятора.
  short sShort;
  (dDouble=(fFloat=(iInt=(sShort=(cByte=(3.3/3))))));      // (1)
  // warning C4244 : '=' : conversion from 'double' to 'char', possible loss of data
  // При изменении типа double на char возможна потеря данных, так как присутствует разница в занимаемой памяти.
  // warning C4244: '=' : conversion from 'int' to 'float', possible loss of data
  // Int занимает больше памяти памяти, чем float, поэтому здесь предупреждение о возможной потере данных.
  
  (cByte=(sShort=(iInt=(fFloat=(dDouble=(3.3/3))))));      // (2)
  // warning C4244: '=' : conversion from 'double' to 'float', possible loss of data
  // Возможная потеря данных, так как double занимает 8 байт, а float 4 байта.
  // warning C4244: '=' : conversion from 'float' to 'int', possible loss of data
  // При наличии цифр после запятой теряется часть информации.
  // warning C4244: '=' : conversion from 'short' to 'char', possible loss of data
  // Возможная потеря данных, так как short занимает 2 байта, а char 1 байт.

  //ниже Вам дан пример "небрежного" использования неявного приведения типов, что может 
  // привести к нежелательным результатам - объясните (в комментариях), к каким?
  // Напишите явно преобразования, которые неявно выполняет компилятор

  iInt  =  257;
  cByte  =  iInt; // 257 выходит за пределы диапазона чисел, доступных для типа данных char,
  // от 000100000001 убирается часть и остается 00000001

  unsigned char cN1=255, cN2=2, cSum;
  cSum = cN1 + cN2; // Максимальное значение для unsigned char 255, а здесь сумма равна 257
  // в двоичном формате это 000100000001, 
  // от 000100000001 убирается часть и остается 00000001

  //Сравните предыдущую строчку с приведенной ниже. Объясните (в комментариях),
  //почему в следующей строке не происходит выход за разрядную сетку
  // Напишите явно преобразования, которые неявно выполняет компилятор
  int iSum = cN1+cN2; // Получаем значение int

  //Напишите, почему при сложении одинаковых значений (одинаковых в двоичной системе) 
  // в строках (1) и (2) получаются разные результаты
  // Напишите явно преобразования, которые неявно выполняет компилятор и объясните,
  // что при этом происходит
  char c1=0xff, c2=2;
  unsigned char uc1=0xff, uc2=2;
  int iSum1= c1 + c2;   //(1) c1 = -1, c2 = 2, -1 + 2 = 1
  int iSum2= uc1 + uc2; //(2) uc1 = 255, 255 + 2 = 257


  
// ***********************************************************
  //Задание 2b. Явное приведение типов данных.
  //Проинтерпретируйте результат (значения переменной dDouble) в строке (3)
  // Напишите явно преобразования, которые неявно выполняет компилятор
  int nTmp=100, nn=3;
  dDouble=3.3 + nTmp / nn; // Сначала вычисляется (nTmp/nn), оно равно 33, цифры после запятой убираются
  //  3.3 + 33 = 36.3, результат double. 

  //Получите результат без потери точности с помощью оператора явного
  //приведения типа
//  double dDouble3=...    // (4)
  double dDouble3 = static_cast<double>(nTmp) / nn + 3.3;

  return 0;
}